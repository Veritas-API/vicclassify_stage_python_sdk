# coding: utf-8

"""
    Veritas Information Classifier (VIC)

    APIs

    OpenAPI spec version: Resource Specific
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class VeritasInformationClassifierVICApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def classify(self, **kwargs):
        """
        Determine a document's classification(s)
        Classify a document using the specified policies or the tenant's default policies.   The document can be supplied by value (a stream of bytes) or by reference (a file path).  The document is automatically converted to text where required.   The classification results include the policies matched and suggested classification 'tags' that the caller may associate with the content.  Extra information can optionally be returned giving more details about the content that triggered the classification - this reduces performance but is useful for diagnostics.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.classify(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str tenant_id: The tenant identifier
        :param list[str] policy_id: One or more policies to use for the classification.  If not specified (and the 'policy' parameter is not specified), the tenant's default policies are used.
        :param str policy: A policy to use for the classification (json).  Normally the policies are specified by policyId, which is a reference to a stored policy.  However this option allows a policy to be supplied by value, which is useful (for example) for testing policies before storing them.
        :param list[str] metadata: One or more items of document metadata to use for classification (along with any content provided).   Each item of metadata is specified as a field/value pair separated by a colon, for example auth:Sue Bloggs.   Note that tools such as Swagger may send each field/value pair as a separate form part, but this is not necessary. It is more efficient to send each pair LF-delimited in a single form part.
        :param str metadata_file: Full path to text file containing metadata to use for classification.  Each piece of metadata is specified as a field/value pair separated by a colon, for example auth:Sue Bloggs.  Multiple items of metadata are separated by a line feed (or CRLF). Multi-valued metadata must be specified as separate field/value pairs, for example recp:Sue\\nrecp:Bob.  The text MUST be UTF-8 or UTF-16LE.  The file SHOULD have a byte order mark indicating the encoding.  If the encoding cannot be determined, UTF-8 is assumed.
        :param str document_name: The document name and extension or full path. If known should include at least name and/or . prefixed extension.   If not supplying the document content in the request body then the document's full and accessible path is required.
        :param bool include_matches: If true, the response contains details about the document matches used to determine the classification.  This may have a significant impact on classification performance.
        :param int max_content_matches_per_rule: The maximum number of content matches to include in the match details.   Only relevant if includeMatches is true.   This setting does not affect classification - it only affects the verbosity of the match information returned with the results.
        :param bool skip_text_extraction: If true, the content to classify is assumed to be text and no text extraction is performed.   **This optimization should only be used when the client is sure that the content is text.**   The text MUST be UTF-8 or UTF-16LE. If the content is specified by reference to a file, the file SHOULD have a byte order mark indicating the encoding.  If the encoding cannot be determined, UTF-8 is assumed.
        :param bool skip_whitespace_collapse: If true, the content to classify does not have its whitespace collapsed before classification.   **This optimization should only be used when the client is sure that whitespace has already been collapsed.**   Whitespace collapsing means that all sequences or two or more whitespace characters are replaced by a single space character.   This flag is only valid is skipTextExtraction is true.
        :param file file: The document's binary or text content. Optional when documentName is the document's full and accessible path.   If multiple files are specified, the first is considered the primary document and the remaining files as attachments.
        :return: ClassificationResultCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.classify_with_http_info(**kwargs)
        else:
            (data) = self.classify_with_http_info(**kwargs)
            return data

    def classify_with_http_info(self, **kwargs):
        """
        Determine a document's classification(s)
        Classify a document using the specified policies or the tenant's default policies.   The document can be supplied by value (a stream of bytes) or by reference (a file path).  The document is automatically converted to text where required.   The classification results include the policies matched and suggested classification 'tags' that the caller may associate with the content.  Extra information can optionally be returned giving more details about the content that triggered the classification - this reduces performance but is useful for diagnostics.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.classify_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str tenant_id: The tenant identifier
        :param list[str] policy_id: One or more policies to use for the classification.  If not specified (and the 'policy' parameter is not specified), the tenant's default policies are used.
        :param str policy: A policy to use for the classification (json).  Normally the policies are specified by policyId, which is a reference to a stored policy.  However this option allows a policy to be supplied by value, which is useful (for example) for testing policies before storing them.
        :param list[str] metadata: One or more items of document metadata to use for classification (along with any content provided).   Each item of metadata is specified as a field/value pair separated by a colon, for example auth:Sue Bloggs.   Note that tools such as Swagger may send each field/value pair as a separate form part, but this is not necessary. It is more efficient to send each pair LF-delimited in a single form part.
        :param str metadata_file: Full path to text file containing metadata to use for classification.  Each piece of metadata is specified as a field/value pair separated by a colon, for example auth:Sue Bloggs.  Multiple items of metadata are separated by a line feed (or CRLF). Multi-valued metadata must be specified as separate field/value pairs, for example recp:Sue\\nrecp:Bob.  The text MUST be UTF-8 or UTF-16LE.  The file SHOULD have a byte order mark indicating the encoding.  If the encoding cannot be determined, UTF-8 is assumed.
        :param str document_name: The document name and extension or full path. If known should include at least name and/or . prefixed extension.   If not supplying the document content in the request body then the document's full and accessible path is required.
        :param bool include_matches: If true, the response contains details about the document matches used to determine the classification.  This may have a significant impact on classification performance.
        :param int max_content_matches_per_rule: The maximum number of content matches to include in the match details.   Only relevant if includeMatches is true.   This setting does not affect classification - it only affects the verbosity of the match information returned with the results.
        :param bool skip_text_extraction: If true, the content to classify is assumed to be text and no text extraction is performed.   **This optimization should only be used when the client is sure that the content is text.**   The text MUST be UTF-8 or UTF-16LE. If the content is specified by reference to a file, the file SHOULD have a byte order mark indicating the encoding.  If the encoding cannot be determined, UTF-8 is assumed.
        :param bool skip_whitespace_collapse: If true, the content to classify does not have its whitespace collapsed before classification.   **This optimization should only be used when the client is sure that whitespace has already been collapsed.**   Whitespace collapsing means that all sequences or two or more whitespace characters are replaced by a single space character.   This flag is only valid is skipTextExtraction is true.
        :param file file: The document's binary or text content. Optional when documentName is the document's full and accessible path.   If multiple files are specified, the first is considered the primary document and the remaining files as attachments.
        :return: ClassificationResultCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tenant_id', 'policy_id', 'policy', 'metadata', 'metadata_file', 'document_name', 'include_matches', 'max_content_matches_per_rule', 'skip_text_extraction', 'skip_whitespace_collapse', 'file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method classify" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/classify'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'tenant_id' in params:
            query_params['tenantId'] = params['tenant_id']

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'policy_id' in params:
            form_params.append(('policyId', params['policy_id']))
            collection_formats['policyId'] = 'multi'
        if 'policy' in params:
            form_params.append(('policy', params['policy']))
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))
            collection_formats['metadata'] = 'multi'
        if 'metadata_file' in params:
            form_params.append(('metadataFile', params['metadata_file']))
        if 'document_name' in params:
            form_params.append(('documentName', params['document_name']))
        if 'include_matches' in params:
            form_params.append(('includeMatches', params['include_matches']))
        if 'max_content_matches_per_rule' in params:
            form_params.append(('maxContentMatchesPerRule', params['max_content_matches_per_rule']))
        if 'skip_text_extraction' in params:
            form_params.append(('skipTextExtraction', params['skip_text_extraction']))
        if 'skip_whitespace_collapse' in params:
            form_params.append(('skipWhitespaceCollapse', params['skip_whitespace_collapse']))
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['Bearer']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClassificationResultCollection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
